## 六大基本原则
1. 单一职责原则————SRP Single Responsibility principle
2. 开闭原则————OCP Open Closed Principle
3. 里式替换————LSP Liskov Substitution Principle
4. 依赖倒置————DIP Dependence Inversion Principle
5. 接口隔离————ISP Interface Segregation Principle
6. 迪米特原则———— LOD(Law of Demeter)也称最少知道原则 Least Knowledge Principle
### 单一职责原则

	######找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 ----Head First

定义：就一个类而言，应该仅有一个引起它变化的原因。即一个类应该只负责一个或者一类事情。让每个类只专注于处理自己的方法。
单一职责原则的好处：
	* 可以降低类的复杂度，逻辑也简单很多
	* 提高类的代码可读性，和可维护性，因为不会有其他奇怪的方法来干扰我们理解这个列的含义。
	* 当发生变化的时候，能将变化的影响降到最小，因为只会在这个类中做出修改。
### 开闭原则
定义：开闭原则的定义是软件中的对象（类、模块、函数等）对于扩展是开放的，但是对于修改是关闭的。
当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能引起更多的问题。我们可以用抽象去构建框架，用实现去扩展细节，这样便可以无限的派生。
### 里氏替换原则
定义：
> 所有引用基类的地方必须能能够透明地使用其子类的对象。
里氏替换原则通俗去讲就是：子类可以去扩展父类的功能，但是不能覆盖父类非抽象的方法——即不能改变父类原有的功能。包含以下几层意思：
	1. 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
	2. 子类可以增加自己独有的方法。
	3. 当子类方法重载父类的方法时候，方法的形参要比父类的形参宽松，返回值要比父类的返回值更严格。
里式替换原则之所以这样要求是因为继承有很多缺点，他虽然是复用代码的一种方法，但同时继承在一定程度上违反 了封装，父类的方法和属性对于子类都是透明的；通过里式替换原则可以要求我们的程序建立抽象，通过抽象去建立规范，用实现去扩展细节。
### 依赖倒置原则
依赖倒置指的是一种特殊的解耦方式，简单来说就是：
> 高层模块不应该依赖底层模块，两者都应该依赖其抽象
> 抽象不应该依赖细节
> 细节应该依赖抽象

###接口隔离原则

 针对接口编程，而不是针对实现编程（鸭子模型中，之前的做法就是：行为继承Duck超累的具体实现而来，或是继承某个接口并由子类自行实现而来。这两种方式都是依赖于【实现】，从而导致我们被绑的死死的，没发变更行为）------Head First

定义：
> 客户端不应该依赖他不需要的接口
类间的依赖关系应该建立在最小的接口上。
### 迪米特原则
迪米特原则也被称为最少知道原则，定义：
> 一个对象应该对其他对象保持最少的了解。
因为类与类之间的关系越密切，耦合度越大，当一个类放生改变时，对另一个类的影响也越大，总原则是：低耦合，高内聚。


## Head First
1. 策略模式 --- 定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户